

# 基于多数据源的数据源切换

![](https://devx-blog-images.oss-cn-beijing.aliyuncs.com/images/20250108/90a6f5e15a2941a2857a1a445c0b6e3e.png?x-oss-process=image/auto-orient,1/interlace,1/quality,q_50/format,jpg)


**多数据源切换的基本思路如上图表示的，在方法调用前由用户控制本次方法调用要使用那个数据源，在本次方法调用中所有的 SQL 都将由这个指定的数据源进行执行。**

## 基于 spring 的 AbstractRoutingDataSource 实现

Spring 框架提供了 `org.springframework.jdbc.datasource.lookup.AbstractRoutingDataSource` 抽象类来进行多数据源的路由，需要实现类实现 `determineCurrentLookupKey` 方法，来控制本次执行选择那个数据源。

![](https://devx-blog-images.oss-cn-beijing.aliyuncs.com/images/20250108/0ab8b395110b4f12a63c1100c0fc1a76.png?x-oss-process=image/auto-orient,1/interlace,1/quality,q_50/format,jpg)


```
/**
* Retrieve the current target DataSource. Determines the
* {@link #determineCurrentLookupKey() current lookup key}, performs
* a lookup in the {@link #setTargetDataSources targetDataSources} map,
* falls back to the specified
* {@link #setDefaultTargetDataSource default target DataSource} if necessary.
* @see #determineCurrentLookupKey()
*/
protected DataSource determineTargetDataSource() {
	Assert.notNull(this.resolvedDataSources, "DataSource router not initialized");
	Object lookupKey = determineCurrentLookupKey();
	DataSource dataSource = this.resolvedDataSources.get(lookupKey);
	if (dataSource == null && (this.lenientFallback || lookupKey == null)) {
		dataSource = this.resolvedDefaultDataSource;
	}
	if (dataSource == null) {
		throw new IllegalStateException("Cannot determine target DataSource for lookup key [" + lookupKey + "]");
	}
	return dataSource;
}
```


自己实现 DynamicDataSource：
```
public class DynamicDataSource extends AbstractRoutingDataSource {

    private static final ThreadLocal<String> CONTEXT_HOLDER = new ThreadLocal<>();

    public DynamicDataSource(DataSource defaultTargetDataSource, Map<Object, Object>
targetDataSources) {
        super.setDefaultTargetDataSource(defaultTargetDataSource);
        super.setTargetDataSources(targetDataSources);
        super.afterPropertiesSet();
    }

    @Override
    protected Object determineCurrentLookupKey() {
        return getDataSource();
    }

    public static void setDataSource(String dataSource) {
        CONTEXT_HOLDER.set(dataSource);
    }

    public static String getDataSource() {
        return CONTEXT_HOLDER.get();
    }

    public static void clearDataSource() {
        CONTEXT_HOLDER.remove();
    }
}

```

### 多数据源的切换方式

#### 注解声明式

1. 自定义注解 `@DataSource(name = "writeDataSource")`
2. 自定义切面类，在切面中获取注解中的 `name` 属性值,并调用 `DynamicDataSource#setDataSource(String dataSource)` 方法将 `name` 值传入，这样就完成了对数据源的切换。
3. 使用自定义注解


```
@Service
public class DemoServiceImpl implements DemoService {

	@Autowired
	UserDAO userDAO;

    @Override
    @DataSource(name = "readDataSource")
    public List<User> read() {
        return userDAO.list();
    }

    @Override
    @DataSource(name = "writeDataSource")
    public void write(User user) {
        userDAO.insert(user);
    }
}
```


4.配置多数据源


```
spring:
  datasource:
    type: com.alibaba.druid.pool.DruidDataSource
    datasource1:
      url: jdbc:mysql://127.0.0.1:3306/datasource1?serverTimezone=UTC&useUnicode=true&characterEncoding=UTF8&useSSL=false
      username: root
      password: 123456
      initial-size: 1
      min-idle: 1
      max-active: 20
      test-on-borrow: true
      driver-class-name: com.mysql.cj.jdbc.Driver
    datasource2:
      url: jdbc:mysql://127.0.0.1:3306/datasource2?serverTimezone=UTC&useUnicode=true&characterEncoding=UTF8&useSSL=false
      username: root
      password: 123456
      initial-size: 1
      min-idle: 1
      max-active: 20
      test-on-borrow: true
      driver-class-name: com.mysql.cj.jdbc.Driver
```

```
@Configuration
public class DynamicDataSourceConfig {

    @Bean
    @ConfigurationProperties("spring.datasource.datasource1")
    public DataSource firstDataSource(){
        return DruidDataSourceBuilder.create().build();
    }

    @Bean
    @ConfigurationProperties("spring.datasource.datasource2")
    public DataSource secondDataSource(){
        return DruidDataSourceBuilder.create().build();
    }

    @Bean
    @Primary
    public DynamicDataSource dataSource(DataSource firstDataSource, DataSource secondDataSource) {
        Map<Object, Object> targetDataSources = new HashMap<>(5);
        targetDataSources.put(DataSourceNames.FIRST, firstDataSource);
        targetDataSources.put(DataSourceNames.SECOND, secondDataSource);
        return new DynamicDataSource(firstDataSource, targetDataSources);
    }

}

```

**这种方式存在一个问题是没有解决分布式事务的问题，如果多个数据源分别连接的是物理隔离的数据库，在一个方法中对这多个库都执行了写操作，此时是没有事务保障的。**


## 使用开源库

> 在 github 经过寻找筛选找了一个使用比较多的 [`dynamic-datasource-spring-boot-starter`](https://gitee.com/baomidou/dynamic-datasource-spring-boot-starter?_from=gitee_search"`dynamic-datasource-spring-boot-starter`")，
支持多数据源 动态数据源 主从分离 读写分离 分布式事务。

### dynamic-datasource-spring-boot-starter 特性

- 支持 数据源分组 ，适用于多种场景 纯粹多库 读写分离 一主多从 混合模式。
- 支持数据库敏感配置信息 加密(可自定义) ENC()。
- 支持每个数据库独立初始化表结构schema和数据库database。
- 支持无数据源启动，支持懒加载数据源（需要的时候再创建连接）。
- 支持 自定义注解 ，需继承DS(3.2.0+)。
- 提供并简化对Druid，HikariCp，BeeCp,Dbcp2的快速集成。
- 提供对Mybatis-Plus，Quartz，ShardingJdbc，P6sy，Jndi等组件的集成方案。
- 提供 自定义数据源来源 方案（如全从数据库加载）。
- 提供项目启动后 动态增加移除数据源 方案。
- 提供Mybatis环境下的 纯读写分离 方案。
- 提供使用 spel动态参数 解析数据源方案。内置spel，session，header，支持自定义。
- 支持 多层数据源嵌套切换 。（ServiceA >>> ServiceB >>> ServiceC）。
- 提供 基于seata的分布式事务方案 。
- 提供 本地多数据源事务方案。


### dynamic-datasource-spring-boot-starter 使用

引入依赖
```
<dependency>
  <groupId>com.baomidou</groupId>
  <artifactId>dynamic-datasource-spring-boot-starter</artifactId>
  <version>${version}</version>
</dependency>
```

配置多数据源
```
spring:
  datasource:
    dynamic:
      primary: master #设置默认的数据源或者数据源组,默认值即为master
      strict: false #严格匹配数据源,默认false. true未匹配到指定数据源时抛异常,false使用默认数据源
      datasource:
        master:
          url: jdbc:mysql://xx.xx.xx.xx:3306/dynamic
          username: root
          password: 123456
          driver-class-name: com.mysql.jdbc.Driver # 3.2.0开始支持SPI可省略此配置
        slave_1:
          url: jdbc:mysql://xx.xx.xx.xx:3307/dynamic
          username: root
          password: 123456
          driver-class-name: com.mysql.jdbc.Driver
        slave_2:
          url: ENC(xxxxx) # 内置加密,使用请查看详细文档
          username: ENC(xxxxx)
          password: ENC(xxxxx)
          driver-class-name: com.mysql.jdbc.Driver
       #......省略
       #以上会配置一个默认库master，一个组slave下有两个子库slave_1,slave_2
```

代码层面使用

```
@Service
@DS("slave")
public class UserServiceImpl implements UserService {

  @Autowired
  private JdbcTemplate jdbcTemplate;

  public List selectAll() {
    return  jdbcTemplate.queryForList("select * from user");
  }
  
  @Override
  @DS("slave_1")
  public List selectByCondition() {
    return  jdbcTemplate.queryForList("select * from user where age >10");
  }
}
```

**多数据源这种方式较为简单使用成本较低，缺点是只能进行读写的分离不能进行数据的水平拆分，对业务端代码有侵入性。**